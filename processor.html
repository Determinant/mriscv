
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Make a RISC-V processor &#8212; mriscv  documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="make-a-risc-v-processor">
<h1>Make a RISC-V processor<a class="headerlink" href="#make-a-risc-v-processor" title="Permalink to this headline">¶</a></h1>
<div class="section" id="what-makes-a-processor">
<h2>What Makes a Processor?<a class="headerlink" href="#what-makes-a-processor" title="Permalink to this headline">¶</a></h2>
<p>A processor, like the name suggests, <em>processes</em> data via computation. More
specifically, the prevailing modern computer processors adopt a computation
model that is largely inspired by Turing Machine (as opposed to Lambda
Calculus, which gave birth to functional programming languages). A typical
processor has three main functions for its operation:</p>
<ol class="arabic simple">
<li><p>The ability of taking input data from the containing system and putting
results back to it. (I/O)</p></li>
<li><p>The ability of processing the data, such as doing arithmetic or logical
operations. (Computation)</p></li>
<li><p>The ability of maintaining an internal state, which could affect its behavior
during processing. (State and Control)</p></li>
</ol>
<p>Without any one of them, the construct sounds less “exciting”: without
I/O, a processor makes no difference from a dummy blackbox that does nothing
inside; without computation, the processor can only output data as-is; without being
stateful, a processor is a simple calculator whose outputs are
immediately determined by its inputs (which could be implemented solely by
<em>combinational logic</em> circuits, which will be discussed soon) and the system
won’t be stateful to control other things. Many mechanical systems are
stateful, such as your wrist watch, which keeps track of the current time as
the state and changes it as time ticks. In fact, a mechanical watch/clock <em>is</em>
a computer/processor as it takes inputs (you can adjust the time and set the alarm),
generates outputs (you can always check the time from the display), process the data (basic
arithmetic to maintain the current time) and has state and control (triggers
second/minute/hour hands according to its internal state) – it is just not a
<em>general-purpose</em> computer. However, interesting mechanical computers
do exist in history [link here].</p>
<p>Although the industry has been evolving its technology in the past decades, the
basic logic for a processor hasn’t been much different from its
theoretical model: like a Turning machine takes commands from a tape that
instructs its next operation, a CPU fetches the next <em>instruction</em> from a
(logically or physically) continuous portion of memory (or from the cache). It
also changes its internal state by the instruction like the Turning machine can
modify its state register. However, when it comes to details, the processor
architectures may differ in how they manage/layout their internal/external
states or how they interpret the instructions. Here we choose RISC-V as our target <em>Instruction Set Architecture</em>
(ISA) for our processor build. RISC-V is <em>register-based</em>, meaning all
temporary values are kept by registers in a <em>register file</em>, like lockers in a
locker room, individually indexed by names (<code class="docutils literal notranslate"><span class="pre">x0</span></code>-<code class="docutils literal notranslate"><span class="pre">x31</span></code> in RV32). They’re directly
accessible, unlike <em>stack-based</em> alternatives which usually have to push to/pop from
a stack of values by their operations.
It is also a <em>register-to-register</em> (aka. <em>load/store</em>) architecture, where all
operations are done on the basis of registers, so that values have to be loaded
from the memory to registers before a computation and stored back to the
memory explicitly from registers afterwards, unlike many CISC architectures such as x86
which supports mixed use of values both from memory and registers (a <em>register-memory</em>
architecture).</p>
<p>With these basics in mind, obviously, we need to have different parts of the
processor to take care of the three major functions. There should be a way to
<em>decode</em> the instruction into some form of internal, temporary representation of
its functionality, so as to <em>control</em> how the rest part of computation should be
carried out. There should be some logic for doing the actual calculation, some
organized internal “lockers” to hold the values and some logic to read/write
the results from/to the main memory. Finally, there should be a loop-like logic to drive
the entire composition of different parts, so the processor can move onto the next
instruction and keep executing instructions one after another with full
automation, like a machine gun.</p>
</div>
<div class="section" id="register-transfer-level-abstraction">
<h2>Register Transfer Level Abstraction<a class="headerlink" href="#register-transfer-level-abstraction" title="Permalink to this headline">¶</a></h2>
<p>It is not very hard to notice such a powerful construct could be implemented by
repeatedly applying two kinds of “logic”:</p>
<ul class="simple">
<li><p>the logic that is like a math expression, which calculates an “immediate”
output (response) from the given input (signal) by pure, stateless logic
operation,</p></li>
<li><p>the logic that “remembers” something, controlled by some external signal, which
could be later altered or read out. (Like a “sequencer/synthesizer”, if you’re familiar
with electronic music.)</p></li>
</ul>
<p>In short, one gives us some math calculation, called <em>combinational logic</em>, while the
other one introduces the notion of states, called <em>sequential logic</em>.</p>
<p>Indeed, in digital circuit design, there is a widely used abstraction that
is based on this observation. Register Transfer Level (RTL) is used by languages
like Verilog/SystemVerilog and VHDL to create a high-level schematics of logic circuits. It
describes the logical behavior with these two kinds of logic as primitives, without having
to dive too much into their low-level (gate-level) implementation.
Each kind of logic usually has patterns and disciplines for its implementation
and can be either automatically synthesized by specialized tools or hand-crafted if
necessary (or both), while the RTL language can abstract this away so the
design task can be divided into high-level logic design and low-level
implementation (e.g. the use of basic gates and wiring/routing).</p>
<p>Combinational logic is usually implemented directly with
the wiring of a cascade of basic logic gates (e.g. NAND/NOR gates). For a concrete
example, a 2-input <em>multiplexer</em> (or simply “mux”) can be implemented as in the diagram:</p>
<a class="reference internal image-reference" href="_images/mux.svg"><img alt="_images/mux.svg" class="align-center" src="_images/mux.svg" width="60%" /></a>
<p>Each component is a <em>NAND</em> gate where the output is the negation of a logical
“and” of two inputs.  With the shown wiring of four gates, the mux choses between inputs (I<sub>0</sub> vs. I<sub>1</sub>) for the output switched by the control signal A. The value of I<sub>0</sub> will be chosen (Q = I<sub>0</sub>) iff. A = 1.</p>
<p>As a comparison, in SystemVerilog (a popular RTL language), the mux can be implemented as:</p>
<div class="highlight-verilog notranslate"><div class="highlight"><pre><span></span><span class="c1">// 2-input mux</span>
<span class="k">module</span> <span class="n">mux2</span><span class="p">(</span><span class="k">input</span> <span class="n">i0</span><span class="p">,</span> <span class="k">input</span> <span class="n">i1</span><span class="p">,</span> <span class="k">input</span> <span class="n">a</span><span class="p">,</span> <span class="k">output</span> <span class="n">q</span><span class="p">);</span>
    <span class="c1">// Combinational logic is a direct assignment to</span>
    <span class="c1">// the wire from an expression.</span>
    <span class="c1">// Since it is time-independent, the order of</span>
    <span class="c1">// assignments does not matter (unlike many</span>
    <span class="c1">// programming languages).</span>
    <span class="k">assign</span> <span class="n">q</span> <span class="o">=</span> <span class="n">a</span> <span class="o">?</span> <span class="n">i0</span> <span class="o">:</span> <span class="n">i1</span><span class="p">;</span>
<span class="k">endmodule</span>
</pre></div>
</div>
<p>There is one thing that’s worth noting: the “calculation” here happens
almost instantaneously as the underlying logic gates “maintain” their outputs from
their inputs by physics (the use of semi-conductors). There is, however, still some
time delay due to physical properties of the gates and the time for electrons
to propagate on the wire or within the semi-conductors, at the scale of
nano-seconds. Thus, the delay is largely affected by the depth gates wiring and
complexity of the overall construction.</p>
<p>Sequential logic, however, is very different. Here we only discuss about
<em>synchronous</em> sequential logic. As the main building block for such a logic, a <em>flip-flop</em> not
only takes input as in combinational logic, but also requires a <em>clock</em> signal
that drives it. In sequential logic, outputs are only stabilized and deemed as
valid when the clock signal pulses (“rising edge”, going to 0 to 1; or “falling edge”, 1 to 0). The use of an
additional clock signal effectively introduces the notion of time into the
logic (unlike combinational logic, which is time-independent). The notion of
discrete time also makes the changing state easy to reason about and
manipulate.  Interestingly, such seemingly “magical” building blocks can be
still implemented by pure wiring of gates, to be stateful. The extra clock signal (or
“reset signal”, for “latches”, its asynchronous counterpart) is the key
ingredient that does the trick. The below diagram shows a wiring scheme for
“D-type” flip-flop with NAND gates, which is a commonly used component in
synthesizing sequential logic. In this flip-flop, the output (Q) will retain
the “memorized” value, when the clock signal (Clk) is 0, and change to the
input (D) when the clock is 1.</p>
<a class="reference internal image-reference" href="_images/d-flip-flop.svg"><img alt="_images/d-flip-flop.svg" class="align-center" src="_images/d-flip-flop.svg" width="60%" /></a>
<p>Sequential logic in SystemVerilog below may be synthesized/hand-crafted by a D-type
flip flop.</p>
<div class="highlight-verilog notranslate"><div class="highlight"><pre><span></span><span class="k">module</span> <span class="n">flip_flop</span><span class="p">(</span><span class="k">input</span> <span class="n">d</span><span class="p">,</span> <span class="k">input</span> <span class="n">clk</span><span class="p">,</span> <span class="k">output</span> <span class="kt">reg</span> <span class="n">q</span><span class="p">);</span>
    <span class="c1">// Sequential logic has notion of time.</span>
    <span class="c1">// It can only be specified with in an `always*` block.</span>
    <span class="k">always_ff</span> <span class="p">@</span> <span class="p">(</span><span class="k">posedge</span> <span class="n">clk</span><span class="p">)</span> <span class="k">begin</span>
        <span class="c1">// Change the output only at</span>
        <span class="c1">// the positive clock edge (clk = 1).</span>
        <span class="n">q</span> <span class="o">&lt;=</span> <span class="n">d</span><span class="p">;</span>
    <span class="k">end</span>
<span class="k">endmodule</span>
</pre></div>
</div>
<p>Finally, consider the scenario where we combine both kinds of logic together: we
wire the input of a combinational logic from the output of a D-type flip-flop,
and then wire the combinational output to the flip-flop input. It creates a
“loop” which takes the output from the current state and puts the new value to
the next state after calculation, implementing an iterator whose iterations are
driven by the clock signal.</p>
<div class="highlight-verilog notranslate"><div class="highlight"><pre><span></span><span class="k">module</span> <span class="n">counter</span><span class="p">(</span><span class="k">input</span> <span class="n">d</span><span class="p">,</span> <span class="k">input</span> <span class="n">rst</span><span class="p">,</span> <span class="k">input</span> <span class="n">clk</span><span class="p">,</span> <span class="k">output</span> <span class="kt">reg</span> <span class="n">q</span><span class="p">);</span>
    <span class="c1">// A counter, whose value could be set to `d` when</span>
    <span class="c1">// `rst` = 1 on the positive edge of `clk`, or increased</span>
    <span class="c1">// by 1 when `rst` = 0 and clocked.</span>

    <span class="c1">// combinational logic, a 2-input mux.</span>
    <span class="kt">wire</span> <span class="n">comb_result</span> <span class="o">=</span> <span class="n">rst</span> <span class="o">?</span> <span class="n">d</span> <span class="o">:</span> <span class="p">(</span><span class="n">q</span> <span class="o">+</span> <span class="mh">1</span><span class="p">);</span>
    <span class="c1">// sequential logic, to alter the state (&quot;reg&quot; for the</span>
    <span class="c1">// register, wired to `q`)</span>
    <span class="k">always_ff</span> <span class="p">@</span> <span class="p">(</span><span class="k">posedge</span> <span class="n">clk</span><span class="p">)</span> <span class="k">begin</span>
        <span class="n">q</span> <span class="o">&lt;=</span> <span class="n">comb_result</span><span class="p">;</span>
    <span class="k">end</span>
<span class="k">endmodule</span>
</pre></div>
</div>
<p>Of course, the period of the clock signal (more
precisely, the minimum gap between two clock cycles) should be conservatively
chosen to be larger than the circuit time of the combinational logic, so the
input to the flip-flop is stabilized before the next clock ticks. This also reveals
why processors nowadays are “pipelined”, the topic of the next section.</p>
</div>
<div class="section" id="instruction-pipelining">
<h2>Instruction Pipelining<a class="headerlink" href="#instruction-pipelining" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="decoder-parsing-an-instruction">
<h2>Decoder: Parsing an Instruction<a class="headerlink" href="#decoder-parsing-an-instruction" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="executor-all-about-computing">
<h2>Executor: All About “Computing”<a class="headerlink" href="#executor-all-about-computing" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="fetcher-automation-and-loop">
<h2>Fetcher: Automation and Loop<a class="headerlink" href="#fetcher-automation-and-loop" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="memory-access-writeback">
<h2>Memory Access &amp; Writeback<a class="headerlink" href="#memory-access-writeback" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="resolving-inter-stage-dependency">
<h2>Resolving Inter-Stage Dependency<a class="headerlink" href="#resolving-inter-stage-dependency" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="when-the-execution-gets-interrupted">
<h2>When the Execution Gets Interrupted…<a class="headerlink" href="#when-the-execution-gets-interrupted" title="Permalink to this headline">¶</a></h2>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">mriscv</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2021, Ted Yin.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.0.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/processor.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>