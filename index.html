
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Minimum RISC-V System From Scratch &#8212; mriscv  documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="minimum-risc-v-system-from-scratch">
<h1>Minimum RISC-V System From Scratch<a class="headerlink" href="#minimum-risc-v-system-from-scratch" title="Permalink to this headline">¶</a></h1>
<p>So, we’ll make a RISC-V system! It may sound “mission impossible” to build this
kind of thing from scratch in a relatively short time, without prior background
in hardware designs.  But it really isn’t as magical as it seems. I hope this
tutorial could serve as a tiny but inspiring guide to those programmers who
know little about hardware like I did to have a better understanding of how a
computer system works from the ground up, and for those who know a bit about
different pieces of the story but can’t put them together.</p>
<p>Nothing is better than having a playable example that is both small and
functional.  This repo already contains a RISC-V processor core implementation
that is synthesizable by itself, but also directly works with a minimal
emulator (Verilator-based) code with a realistic system setup. The processor
implements RV32I instruction set with major part of CSR Mode-M, while the
emulator emulates the cache/memory, serial console output, video output and
keyboard input. The applications are built with standard gcc/Rust RISC-V
toolchains and directly run on the processor.</p>
<p>The whole repo is simply divided into three parts:</p>
<ul class="simple">
<li><p>Processor core implementation in Verilog: <code class="docutils literal notranslate"><span class="pre">core.sv</span></code> (1.2K loc) and
<code class="docutils literal notranslate"><span class="pre">csr.sv</span></code> (182 loc).</p></li>
<li><p>System emulator: <code class="docutils literal notranslate"><span class="pre">sim.cpp</span></code> (423 loc).</p></li>
<li><p>Example applications that directly runs on <code class="docutils literal notranslate"><span class="pre">sim</span></code>: <code class="docutils literal notranslate"><span class="pre">apps/*.c</span></code> and
<code class="docutils literal notranslate"><span class="pre">apps/mriscv-rs/examples/*.rs</span></code>.</p></li>
</ul>
<p>This tutorial is organized in two parts: the implementation of the processor
core with Verilog and the building of the final system/applications.</p>
<div class="toctree-wrapper compound">
</div>
<div class="section" id="make-a-risc-v-processor">
<h2>Make a RISC-V processor<a class="headerlink" href="#make-a-risc-v-processor" title="Permalink to this headline">¶</a></h2>
<div class="section" id="what-makes-a-processor">
<h3>What Makes a Processor?<a class="headerlink" href="#what-makes-a-processor" title="Permalink to this headline">¶</a></h3>
<p>A processor, like the name suggests, <em>processes</em> data via computation. More
specifically, the prevailing modern computer processors adopt a computation
model that is largely inspired by Turing Machine (as opposed to Lambda
Calculus, which gave birth to functional programming languages). A typical
processor has three main functions for its operation:</p>
<ol class="arabic simple">
<li><p>The ability of taking input data from the containing system and putting
results back to it. (I/O)</p></li>
<li><p>The ability of processing the data, such as doing arithmetic or logical
operations. (Computation)</p></li>
<li><p>The ability of maintaining an internal state, which could affect its behavior
during processing. (State and Control)</p></li>
</ol>
<p>Without any one of them, the construct sounds less “exciting”: without
I/O, a processor makes no difference from a dummy blackbox that does nothing
inside; without computation, the processor can only output data as-is; without being
stateful, a processor is a simple calculator whose outputs are
immediately determined by its inputs (which could be implemented solely by
<em>combinational logic</em> circuits, which will be discussed soon) and the system
won’t be stateful to control other things. Many mechanical systems are
stateful, such as your wrist watch, which keeps track of the current time as
the state and changes it as time ticks. In fact, a mechanical watch/clock <em>is</em>
a computer/processor as it takes inputs (you can adjust the time and set the alarm),
generates outputs (you can always check the time from the display), process the data (basic
arithmetic to maintain the current time) and has state and control (triggers
second/minute/hour hands according to its internal state) – it is just not a
<em>general-purpose</em> computer. However, interesting mechanical computers
do exist in history [link here].</p>
<p>Although the industry has been evolving its technology in the past decades, the
basic logic for a processor hasn’t been much different from its
theoretical model: like a Turning machine takes commands from a tape that
instructs its next operation, a CPU fetches the next <em>instruction</em> from a
(logically or physically) continuous portion of memory (or from the cache). It
also changes its internal state by the instruction like the Turning machine can
modify its state register. However, when it comes to details, the processor
architectures may differ in how they manage/layout their internal/external
states or how they interpret the instructions. Here we choose RISC-V as our target <em>Instruction Set Architecture</em>
(ISA) for our processor build. RISC-V is <em>register-based</em>, meaning all
temporary values are kept by registers in a <em>register file</em>, like lockers in a
locker room, individually indexed by names (<code class="docutils literal notranslate"><span class="pre">x0</span></code>-<code class="docutils literal notranslate"><span class="pre">x31</span></code> in RV32). They’re directly
accessible, unlike <em>stack-based</em> alternatives which usually have to push to/pop from
a stack of values by their operations.
It is also a <em>register-to-register</em> (aka. <em>load/store</em>) architecture, where all
operations are done on the basis of registers, so that values have to be loaded
from the memory to registers before a computation and stored back to the
memory explicitly from registers afterwards, unlike many CISC architectures such as x86
which supports mixed use of values both from memory and registers (a <em>register-memory</em>
architecture).</p>
<p>With these basics in mind, obviously, we need to have different parts of the
processor to take care of the three major functions. There should be a way to
<em>decode</em> the instruction into some form of internal, temporary representation of
its functionality, so as to <em>control</em> how the rest part of computation should be
carried out. There should be some logic for doing the actual calculation, some
organized internal “lockers” to hold the values and some logic to read/write
the results from/to the main memory. Finally, there should be a loop-like logic to drive
the entire composition of different parts, so the processor can move onto the next
instruction and keep executing instructions one after another with full
automation, like a machine gun.</p>
</div>
<div class="section" id="register-transfer-level-abstraction">
<h3>Register Transfer Level Abstraction<a class="headerlink" href="#register-transfer-level-abstraction" title="Permalink to this headline">¶</a></h3>
<p>It is not very hard to notice such a powerful construct could be implemented by
repeatedly applying two kinds of “logic”:</p>
<ul class="simple">
<li><p>the logic that is like a math expression, which calculates an “immediate”
output (response) from the given input (signal) by pure, stateless logic
operation,</p></li>
<li><p>the logic that “remembers” something, controlled by some external signal, which
could be later altered or read out. (Like a “sequencer/synthesizer”, if you’re familiar
with electronic music.)</p></li>
</ul>
<p>In short, one gives us some math calculation, called <em>combinational logic</em>, while the
other one introduces the notion of states, called <em>sequential logic</em>.</p>
<p>Indeed, in digital circuit design, there is a widely used abstraction that
is based on this observation. Register Transfer Level (RTL) is used by languages
like Verilog/SystemVerilog and VHDL to create a high-level schematics of logic circuits. It
describes the logical behavior with these two kinds of logic as primitives, without having
to dive too much into their low-level (gate-level) implementation.
Each kind of logic usually has patterns and disciplines for its implementation
and can be either automatically synthesized by specialized tools or hand-crafted if
necessary (or both), while the RTL language can abstract this away so the
design task can be divided into high-level logic design and low-level
implementation (e.g. the use of basic gates and wiring/routing).</p>
<p>Combinational logic is usually implemented directly with
the wiring of a cascade of basic logic gates (e.g. NAND/NOR gates). For a concrete
example, a 2-input <em>multiplexer</em> (or simply “mux”) can be implemented as in the diagram:</p>
<a class="reference internal image-reference" href="_images/mux.svg"><img alt="_images/mux.svg" class="align-center" src="_images/mux.svg" width="60%" /></a>
<p>Each component is a <em>NAND</em> gate where the output is the negation of a logical
“and” of two inputs.  With the shown wiring of four gates, the mux choses between inputs (I<sub>0</sub> vs. I<sub>1</sub>) for the output switched by the control signal A. The value of I<sub>0</sub> will be chosen (Q = I<sub>0</sub>) iff. A = 1.</p>
<p>As a comparison, in SystemVerilog (a popular RTL language), the mux can be implemented as:</p>
<div class="highlight-verilog notranslate"><div class="highlight"><pre><span></span><span class="c1">// 2-input mux</span>
<span class="k">module</span> <span class="n">mux2</span><span class="p">(</span><span class="k">input</span> <span class="n">i0</span><span class="p">,</span> <span class="k">input</span> <span class="n">i1</span><span class="p">,</span> <span class="k">input</span> <span class="n">a</span><span class="p">,</span> <span class="k">output</span> <span class="n">q</span><span class="p">);</span>
    <span class="c1">// Combinational logic is a direct assignment to</span>
    <span class="c1">// the wire from an expression.</span>
    <span class="c1">// Since it is time-independent, the order of</span>
    <span class="c1">// assignments does not matter (unlike many</span>
    <span class="c1">// programming languages).</span>
    <span class="k">assign</span> <span class="n">q</span> <span class="o">=</span> <span class="n">a</span> <span class="o">?</span> <span class="n">i0</span> <span class="o">:</span> <span class="n">i1</span><span class="p">;</span>
<span class="k">endmodule</span>
</pre></div>
</div>
<p>There is one thing that’s worth noting: the “calculation” here happens
almost instantaneously as the underlying logic gates “maintain” their outputs from
their inputs by physics (the use of semi-conductors). There is, however, still some
time delay due to physical properties of the gates and the time for electrons
to propagate on the wire or within the semi-conductors, at the scale of
nano-seconds. Thus, the delay is largely affected by the depth gates wiring and
complexity of the overall construction.</p>
<p>Sequential logic, however, is very different. Here we only discuss about
<em>synchronous</em> sequential logic. As the main building block for such a logic, a <em>flip-flop</em> not
only takes input as in combinational logic, but also requires a <em>clock</em> signal
that drives it. In sequential logic, outputs are only stabilized and deemed as
valid when the clock signal pulses (“rising edge”, going to 0 to 1; or “falling edge”, 1 to 0). The use of an
additional clock signal effectively introduces the notion of time into the
logic (unlike combinational logic, which is time-independent). The notion of
discrete time also makes the changing state easy to reason about and
manipulate.  Interestingly, such seemingly “magical” building blocks can be
still implemented by pure wiring of gates, to be stateful. The extra clock signal (or
“reset signal”, for “latches”, its asynchronous counterpart) is the key
ingredient that does the trick. The below diagram shows a wiring scheme for
“D-type” flip-flop with NAND gates, which is a commonly used component in
synthesizing sequential logic. In this flip-flop, the output (Q) will retain
the “memorized” value, when the clock signal (Clk) is 0, and change to the
input (D) when the clock is 1.</p>
<a class="reference internal image-reference" href="_images/d-flip-flop.svg"><img alt="_images/d-flip-flop.svg" class="align-center" src="_images/d-flip-flop.svg" width="60%" /></a>
<p>Sequential logic in SystemVerilog below may be synthesized/hand-crafted by a D-type
flip flop.</p>
<div class="highlight-verilog notranslate"><div class="highlight"><pre><span></span><span class="k">module</span> <span class="n">flip_flop</span><span class="p">(</span><span class="k">input</span> <span class="n">d</span><span class="p">,</span> <span class="k">input</span> <span class="n">clk</span><span class="p">,</span> <span class="k">output</span> <span class="kt">reg</span> <span class="n">q</span><span class="p">);</span>
    <span class="c1">// Sequential logic has notion of time.</span>
    <span class="c1">// It can only be specified with in an `always*` block.</span>
    <span class="k">always_ff</span> <span class="p">@</span> <span class="p">(</span><span class="k">posedge</span> <span class="n">clk</span><span class="p">)</span> <span class="k">begin</span>
        <span class="c1">// Change the output only at</span>
        <span class="c1">// the positive clock edge (clk = 1).</span>
        <span class="n">q</span> <span class="o">&lt;=</span> <span class="n">d</span><span class="p">;</span>
    <span class="k">end</span>
<span class="k">endmodule</span>
</pre></div>
</div>
<p>Finally, consider the scenario where we combine both kinds of logic together: we
wire the input of a combinational logic from the output of a D-type flip-flop,
and then wire the combinational output to the flip-flop input. It creates a
“loop” which takes the output from the current state and puts the new value to
the next state after calculation, implementing an iterator whose iterations are
driven by the clock signal.</p>
<div class="highlight-verilog notranslate"><div class="highlight"><pre><span></span><span class="k">module</span> <span class="n">counter</span><span class="p">(</span><span class="k">input</span> <span class="n">d</span><span class="p">,</span> <span class="k">input</span> <span class="n">rst</span><span class="p">,</span> <span class="k">input</span> <span class="n">clk</span><span class="p">,</span> <span class="k">output</span> <span class="kt">reg</span> <span class="n">q</span><span class="p">);</span>
    <span class="c1">// A counter, whose value could be set to `d` when</span>
    <span class="c1">// `rst` = 1 on the positive edge of `clk`, or increased</span>
    <span class="c1">// by 1 when `rst` = 0 and clocked.</span>

    <span class="c1">// combinational logic, a 2-input mux.</span>
    <span class="kt">wire</span> <span class="n">comb_result</span> <span class="o">=</span> <span class="n">rst</span> <span class="o">?</span> <span class="n">d</span> <span class="o">:</span> <span class="p">(</span><span class="n">q</span> <span class="o">+</span> <span class="mh">1</span><span class="p">);</span>
    <span class="c1">// sequential logic, to alter the state (&quot;reg&quot; for the</span>
    <span class="c1">// register, wired to `q`)</span>
    <span class="k">always_ff</span> <span class="p">@</span> <span class="p">(</span><span class="k">posedge</span> <span class="n">clk</span><span class="p">)</span> <span class="k">begin</span>
        <span class="n">q</span> <span class="o">&lt;=</span> <span class="n">comb_result</span><span class="p">;</span>
    <span class="k">end</span>
<span class="k">endmodule</span>
</pre></div>
</div>
<p>Of course, the period of the clock signal (more
precisely, the minimum gap between two clock cycles) should be conservatively
chosen to be larger than the circuit time of the combinational logic, so the
input to the flip-flop is stabilized before the next clock ticks. This also reveals
why processors nowadays are “pipelined”, the topic of the next section.</p>
</div>
<div class="section" id="instruction-pipelining">
<h3>Instruction Pipelining<a class="headerlink" href="#instruction-pipelining" title="Permalink to this headline">¶</a></h3>
<p>There are many possible schemes for a processor design. The simplest idea is
to utilze the “loop” we just talked about to mainly divide the processor into
two parts:</p>
<ul class="simple">
<li><p>Computation: this part can be built with a cascade of combinational logics
that “generates” the result from the wire, as signals go through a series of
gates.  More specifically, it first decodes the instruction into data and control
signals.  Then it immediately wires the data into an <em>Arithmetic Logic Unit</em>
(ALU). An ALU is built by a mux which selects the kind of calculation the
instruction needs to perform, given the control signal. It may also use the
operands from the register files, which is the current state of the
underlying flip-flops. Overall, the next state for the processor is prepared
in this giant fabric of purely combinational logic.</p></li>
<li><p>State Transition: the results from the computation logic are ephemeral, like
the other end of an eletric wire. We thus would like a sequential logic that
finally updates the processor’s state before the clock cycle ends. Usually such sequential logic
is done together with the register file, which writes back the outcome of the
execution to its flip-flops. The changed values will become available again
at the beginning of the next cycle, when used again by the combinational
logic by the computation.</p></li>
</ul>
<p>The scheme is usually called a <em>single cycle</em> processor. The main
advantage of choosing this scheme is that it is fairly easy to implement with limited number of gates
and low complexity. It has many downsides, so few modern processors still use
it. A major one is the processing throughput (e.g. instruction per
sercond) equals to the clock frequency as the processor can exactly handle
only one instruction per cycle. Whereas the choice for the clock cycle time is not
arbitrary: like we previously said, the longest circuitry in the
combinational logic for computation sets the lower-bound for the cycle time,
which is not scalable for implementing a modern, realistic CPU, due to the
complicated specification of the ISA. Even worse, the cache/memory access time during the
computation can drag the cycle time even further, resulting in a low average
frequency for the processor.</p>
<p>Nowadays, you would probably see builds of single-cycle processors in some
hobby CPU projects (e.g. built with discrete components like DIP-packaged TTL
logic ICs) and in “Turning-complete” games such as Minecraft/Factorio, where people wish
to have managable amount of work to build a cool proof-of-concept computer.</p>
<p>Therefore, researchers and engineers have come up with numerous ways to get
around this limitation and largely improved the throughput by <em>instruction-level
parallelism</em>. One of the greatest technique that is seen on almost every chips
nowadays is instruction <em>pipelining</em>. The high-level idea though, is simple and
intuitive: we can divide the flow of that “giant” computation logic into
several <em>stages</em> and try to process each instruction as in a car factory with
an assembly pipeline. Each stage has its own sequential logic, so the clock cycle
time only needs to accommodate the longest stage in the pipeline, instead of the entire
pipeline. Therefore, for a given number of stages, the ideal case is we
wisely divide the task so that all stages have similar amount of time for their
combinational logic (similar depth).
This technique is much more scalable than the
single-cycle design, as the designer can choose to use more stages in the
pipeline to account for more complex logic required for the target ISA. For
example, an Intel Skylake CPU (whose ISA is x86-64) has around 14 stages
whereas an ARM Cortex-A77 (whose ISA is ARM64) has 13.</p>
<p>In this <code class="docutils literal notranslate"><span class="pre">mriscv</span></code> project, we use a classic 5-stage pipeline design that divides
the computation into the following stages:</p>
<ul class="simple">
<li><p>instruction fetch (IF)</p></li>
<li><p>instruction decode (ID)</p></li>
<li><p>execution (EX)</p></li>
<li><p>memory access (MEM)</p></li>
<li><p>register file write back (WB)</p></li>
</ul>
<p>which was once a typical arrangement for a RISC processor (e.g. MIPS). There is only one
memory access stage in the pipeline thanks to the simplicity of load/store
nature of RISC: there is no instruction that needs to both access
(load/store) memory and do other computation at the same time, which greately
simplifies the pipeline. Overall, each instruction will do one kind of the operations listed below:</p>
<ul class="simple">
<li><p>math computation with registers, and write back the result to a register;</p></li>
<li><p>memory access: load from/store to memory, based on the address provided by registers and the data destination/source is also a register;</p></li>
<li><p>control flow: conditionally/unconditionally change the current <em>Program
Counter</em> (PC, pointing to the instruction being executed) to other location.</p></li>
</ul>
<p>Unlike many other projects, <code class="docutils literal notranslate"><span class="pre">mriscv</span></code> adopts a clean and modular kind of
organization in its one-file core code (<code class="docutils literal notranslate"><span class="pre">core.sv</span></code>). The five stages are
implemented in their own modules (<code class="docutils literal notranslate"><span class="pre">fetcher</span></code>, <code class="docutils literal notranslate"><span class="pre">decoder</span></code>, <code class="docutils literal notranslate"><span class="pre">executor</span></code>,
<code class="docutils literal notranslate"><span class="pre">memory</span></code> and <code class="docutils literal notranslate"><span class="pre">writeback</span></code>) and put together in <code class="docutils literal notranslate"><span class="pre">core</span></code> module. This
manifests the data path and control lines that each stage offers and requires.
You can also try to tweak/modify the code of one specific stage for your own
purpose.</p>
</div>
<div class="section" id="decoder-parsing-an-instruction">
<h3>Decoder: Parsing an Instruction<a class="headerlink" href="#decoder-parsing-an-instruction" title="Permalink to this headline">¶</a></h3>
<p>If you’re familiar with shell/scripting languages like Bash, Python or
Javascript, you must have heard of the term “interpreter”. Likewise, a
processor is “merely” a hardware-built interpreter that efficiently supports a
handful of commands (instructions) by following their syntax (binary format)
and semantics (behavior) specified by the ISA. As the name suggests, an
interpreter first needs to “understand” what an instruction is all about, by
parsing, or in the term of digital circuits, <em>decoding</em> the given instruction.</p>
<p>Luckily, thanks to the elegant design of RISC-V ISA, the format of instructions
in RV32I is very regular. It tends to use the same structure for similar
instructions and put operands to the same bit portion of the 32-bit word for
most of the instructions. Furthermore, it uses a somewhat hierarchical
approach: with “function” code (<code class="docutils literal notranslate"><span class="pre">funct3</span></code>, <code class="docutils literal notranslate"><span class="pre">funct7</span></code>, etc.), variants of the
same base operation can be treated in the same way for some cases and
differently for their own semantics. Sometimes function code is
deliberately not continuous to allow testing some bit of the code to efficiently
tell the special treatment.</p>
<p>In our <code class="docutils literal notranslate"><span class="pre">decoder</span></code> code, we rename the group of wires according to the bit
fields in a instruction.</p>
<div class="highlight-verilog notranslate"><div class="highlight"><pre><span></span><span class="kt">wire</span> <span class="p">[</span><span class="mh">6</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">opcode</span> <span class="o">=</span> <span class="n">inst</span><span class="p">[</span><span class="mh">6</span><span class="o">:</span><span class="mh">0</span><span class="p">];</span>
<span class="kt">wire</span> <span class="p">[</span><span class="mh">2</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">funct3</span> <span class="o">=</span> <span class="n">inst</span><span class="p">[</span><span class="mh">14</span><span class="o">:</span><span class="mh">12</span><span class="p">];</span>
<span class="kt">wire</span> <span class="p">[</span><span class="mh">11</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">funct12</span> <span class="o">=</span> <span class="n">inst</span><span class="p">[</span><span class="mh">31</span><span class="o">:</span><span class="mh">20</span><span class="p">];</span>
<span class="kt">wire</span> <span class="p">[</span><span class="mh">4</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">rs1</span> <span class="o">=</span> <span class="n">inst</span><span class="p">[</span><span class="mh">19</span><span class="o">:</span><span class="mh">15</span><span class="p">];</span>
<span class="kt">wire</span> <span class="p">[</span><span class="mh">4</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">rs2</span> <span class="o">=</span> <span class="n">inst</span><span class="p">[</span><span class="mh">24</span><span class="o">:</span><span class="mh">20</span><span class="p">];</span>
<span class="kt">wire</span> <span class="p">[</span><span class="mh">4</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">rd</span> <span class="o">=</span> <span class="n">inst</span><span class="p">[</span><span class="mh">11</span><span class="o">:</span><span class="mh">7</span><span class="p">];</span>
<span class="kt">wire</span> <span class="p">[</span><span class="mh">31</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">ui</span> <span class="o">=</span> <span class="p">{</span><span class="n">inst</span><span class="p">[</span><span class="mh">31</span><span class="o">:</span><span class="mh">12</span><span class="p">],</span> <span class="mh">12</span><span class="mb">&#39;b0</span><span class="p">};</span> <span class="c1">//&lt; load upper immediate</span>
<span class="kt">wire</span> <span class="p">[</span><span class="mh">31</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">xxxi</span> <span class="o">=</span> <span class="p">{{</span><span class="mh">20</span><span class="p">{</span><span class="n">inst</span><span class="p">[</span><span class="mh">31</span><span class="p">]}},</span> <span class="n">inst</span><span class="p">[</span><span class="mh">31</span><span class="o">:</span><span class="mh">20</span><span class="p">]};</span> <span class="c1">//&lt; sign-extended immediate</span>
<span class="kt">wire</span> <span class="p">[</span><span class="mh">20</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">jal_offset</span> <span class="o">=</span> <span class="p">{</span><span class="n">inst</span><span class="p">[</span><span class="mh">31</span><span class="p">],</span> <span class="n">inst</span><span class="p">[</span><span class="mh">19</span><span class="o">:</span><span class="mh">12</span><span class="p">],</span> <span class="n">inst</span><span class="p">[</span><span class="mh">20</span><span class="p">],</span> <span class="n">inst</span><span class="p">[</span><span class="mh">30</span><span class="o">:</span><span class="mh">21</span><span class="p">],</span> <span class="mh">1</span><span class="mb">&#39;b0</span><span class="p">};</span>
<span class="kt">wire</span> <span class="p">[</span><span class="mh">11</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">jalr_offset</span> <span class="o">=</span> <span class="n">inst</span><span class="p">[</span><span class="mh">31</span><span class="o">:</span><span class="mh">20</span><span class="p">];</span>
<span class="kt">wire</span> <span class="p">[</span><span class="mh">12</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">b_offset</span> <span class="o">=</span> <span class="p">{</span><span class="n">inst</span><span class="p">[</span><span class="mh">31</span><span class="p">],</span> <span class="n">inst</span><span class="p">[</span><span class="mh">7</span><span class="p">],</span> <span class="n">inst</span><span class="p">[</span><span class="mh">30</span><span class="o">:</span><span class="mh">25</span><span class="p">],</span> <span class="n">inst</span><span class="p">[</span><span class="mh">11</span><span class="o">:</span><span class="mh">8</span><span class="p">],</span> <span class="mh">1</span><span class="mb">&#39;b0</span><span class="p">};</span>
<span class="kt">wire</span> <span class="p">[</span><span class="mh">11</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">l_offset</span> <span class="o">=</span> <span class="n">inst</span><span class="p">[</span><span class="mh">31</span><span class="o">:</span><span class="mh">20</span><span class="p">];</span>
<span class="kt">wire</span> <span class="p">[</span><span class="mh">11</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">s_offset</span> <span class="o">=</span> <span class="p">{</span><span class="n">inst</span><span class="p">[</span><span class="mh">31</span><span class="o">:</span><span class="mh">25</span><span class="p">],</span> <span class="n">inst</span><span class="p">[</span><span class="mh">11</span><span class="o">:</span><span class="mh">7</span><span class="p">]};</span>
<span class="c1">// ... (see core.sv for the complete content)</span>
</pre></div>
</div>
<p>RISC-V instructions usually uses two operand registers (<code class="docutils literal notranslate"><span class="pre">rs1</span></code>, <code class="docutils literal notranslate"><span class="pre">rs2</span></code>) and
one destination register (<code class="docutils literal notranslate"><span class="pre">rd</span></code>). One of the main task the decoder has to do
here is to store the current values of operands to an stage-end register by the
end of the cycle:</p>
<div class="highlight-verilog notranslate"><div class="highlight"><pre><span></span><span class="kt">wire</span> <span class="p">[</span><span class="mh">31</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">op1</span> <span class="o">=</span> <span class="p">(</span><span class="n">ctrl_forward_valid_exec</span> <span class="o">&amp;&amp;</span> <span class="n">rs1</span> <span class="o">==</span> <span class="n">ctrl_forward_rd_exec</span><span class="p">)</span> <span class="o">?</span> <span class="nl">forward_data_exec:</span>
                  <span class="p">(</span><span class="n">ctrl_forward_valid_mem</span> <span class="o">&amp;&amp;</span> <span class="n">rs1</span> <span class="o">==</span> <span class="n">ctrl_forward_rd_mem</span><span class="p">)</span> <span class="o">?</span> <span class="nl">forward_data_mem:</span>
                                                                           <span class="n">reg_rdata1</span><span class="p">;</span>
<span class="kt">wire</span> <span class="p">[</span><span class="mh">31</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">op2</span> <span class="o">=</span> <span class="p">(</span><span class="n">ctrl_forward_valid_exec</span> <span class="o">&amp;&amp;</span> <span class="n">rs2</span> <span class="o">==</span> <span class="n">ctrl_forward_rd_exec</span><span class="p">)</span> <span class="o">?</span> <span class="nl">forward_data_exec:</span>
                  <span class="p">(</span><span class="n">ctrl_forward_valid_mem</span> <span class="o">&amp;&amp;</span> <span class="n">rs2</span> <span class="o">==</span> <span class="n">ctrl_forward_rd_mem</span><span class="p">)</span> <span class="o">?</span> <span class="nl">forward_data_mem:</span>
                                                                           <span class="n">reg_rdata2</span><span class="p">;</span>
</pre></div>
</div>
<p>The combinational logic for <code class="docutils literal notranslate"><span class="pre">op1</span></code> seems a bit more complex than imagined, due to the need for <em>forwarding</em>
that we’ll later get to. For now, let’s ignore these wires/registers with “forward” in their names, so
the actual logic here is:</p>
<div class="highlight-verilog notranslate"><div class="highlight"><pre><span></span><span class="kt">wire</span> <span class="p">[</span><span class="mh">31</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">op1</span> <span class="o">=</span> <span class="n">reg_rdata1</span><span class="p">;</span>
<span class="kt">wire</span> <span class="p">[</span><span class="mh">31</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">op2</span> <span class="o">=</span> <span class="n">reg_rdata2</span><span class="p">;</span>
</pre></div>
</div>
<p>Here, <code class="docutils literal notranslate"><span class="pre">reg_rdata1</span></code> and <code class="docutils literal notranslate"><span class="pre">reg_rdata2</span></code> are the output signals from the
register file (pins from a <code class="docutils literal notranslate"><span class="pre">register_file</span></code> module instance) that keeps
flip-flops for all 32 standard RV32I registers. As part of the combinational
logic, the “addresses” (0-31) of the registers we’d like to access are wired to
<code class="docutils literal notranslate"><span class="pre">rs1</span></code> and <code class="docutils literal notranslate"><span class="pre">rs2</span></code>:</p>
<div class="highlight-verilog notranslate"><div class="highlight"><pre><span></span><span class="c1">// wire to read from register file</span>
<span class="k">assign</span> <span class="n">reg_raddr1</span> <span class="o">=</span> <span class="n">rs1</span><span class="p">;</span>
<span class="k">assign</span> <span class="n">reg_raddr2</span> <span class="o">=</span> <span class="n">rs2</span><span class="p">;</span>
</pre></div>
</div>
<p>The register file is implemented in its own SystemVerilog module, whose interface is:</p>
<div class="highlight-verilog notranslate"><div class="highlight"><pre><span></span><span class="k">module</span> <span class="n">register_file</span><span class="p">(</span>
    <span class="k">input</span> <span class="p">[</span><span class="mh">4</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">raddr1</span><span class="p">,</span>
    <span class="k">input</span> <span class="p">[</span><span class="mh">4</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">raddr2</span><span class="p">,</span>
    <span class="k">output</span> <span class="p">[</span><span class="mh">31</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">rdata1</span><span class="p">,</span>
    <span class="k">output</span> <span class="p">[</span><span class="mh">31</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">rdata2</span><span class="p">,</span>

    <span class="k">input</span> <span class="p">[</span><span class="mh">4</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">waddr</span><span class="p">,</span>
    <span class="k">input</span> <span class="p">[</span><span class="mh">31</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">wdata</span><span class="p">,</span>
    <span class="k">input</span> <span class="n">wen</span><span class="p">,</span> <span class="c1">//&lt; write enable</span>

    <span class="k">input</span> <span class="n">ctrl_clk</span> <span class="c1">//&lt; clock</span>
<span class="p">);</span>
</pre></div>
</div>
<p>In the <code class="docutils literal notranslate"><span class="pre">core</span></code> module, decoder’s pin <code class="docutils literal notranslate"><span class="pre">reg_raddr1</span></code> is wired to <code class="docutils literal notranslate"><span class="pre">raddr1</span></code> and
<code class="docutils literal notranslate"><span class="pre">reg_rdata1</span></code> is wired to <code class="docutils literal notranslate"><span class="pre">rdata1</span></code>. The same is for the other operand.</p>
<p>Another important thing the decoder needs to do, according to the design in
this project, is to calculate whether there is transfer of the control flow:</p>
<div class="highlight-verilog notranslate"><div class="highlight"><pre><span></span><span class="c1">// set jump signal for control transfer instructions</span>
<span class="k">assign</span> <span class="n">ctrl_pc_jump_target</span> <span class="o">=</span>
    <span class="n">opcode</span> <span class="o">==</span> <span class="no">`JAL</span> <span class="o">?</span> <span class="n">pc</span> <span class="o">+</span> <span class="n">$signed</span><span class="p">({{</span><span class="mh">11</span><span class="p">{</span><span class="n">jal_offset</span><span class="p">[</span><span class="mh">20</span><span class="p">]}},</span> <span class="n">jal_offset</span><span class="p">})</span> <span class="o">:</span>
    <span class="n">opcode</span> <span class="o">==</span> <span class="no">`JALR</span> <span class="o">?</span> <span class="n">op1</span> <span class="o">+</span> <span class="n">$signed</span><span class="p">({{</span><span class="mh">20</span><span class="p">{</span><span class="n">jalr_offset</span><span class="p">[</span><span class="mh">11</span><span class="p">]}},</span> <span class="n">jalr_offset</span><span class="p">})</span> <span class="o">:</span>
    <span class="n">opcode</span> <span class="o">==</span> <span class="no">`BXX</span> <span class="o">?</span> <span class="n">pc</span> <span class="o">+</span> <span class="n">$signed</span><span class="p">({{</span><span class="mh">19</span><span class="p">{</span><span class="n">b_offset</span><span class="p">[</span><span class="mh">12</span><span class="p">]}},</span> <span class="n">b_offset</span><span class="p">})</span> <span class="o">:</span> <span class="p">&#39;</span><span class="n">bx</span><span class="p">;</span>
<span class="k">assign</span> <span class="n">ctrl_jump</span> <span class="o">=</span> <span class="p">(</span><span class="o">!</span><span class="n">ctrl_skip_next_reg</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
    <span class="p">(</span><span class="n">opcode</span> <span class="o">==</span> <span class="no">`JAL</span> <span class="o">?</span> <span class="mh">1</span> <span class="o">:</span>
    <span class="n">opcode</span> <span class="o">==</span> <span class="no">`JALR</span> <span class="o">?</span> <span class="mh">1</span> <span class="o">:</span>
    <span class="n">opcode</span> <span class="o">==</span> <span class="no">`BXX</span> <span class="o">?</span>
        <span class="p">(</span><span class="n">funct3</span><span class="p">[</span><span class="mh">2</span><span class="o">:</span><span class="mh">1</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0</span> <span class="o">?</span> <span class="p">((</span><span class="n">op1</span> <span class="o">==</span> <span class="n">op2</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="n">funct3</span><span class="p">[</span><span class="mh">0</span><span class="p">]))</span> <span class="o">:</span> <span class="c1">// BEQ &amp; BNE</span>
         <span class="p">(</span><span class="n">funct3</span><span class="p">[</span><span class="mh">1</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0</span> <span class="o">?</span>
              <span class="p">((</span><span class="n">$signed</span><span class="p">(</span><span class="n">op1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">$signed</span><span class="p">(</span><span class="n">op2</span><span class="p">))</span> <span class="o">^</span> <span class="p">(</span><span class="n">funct3</span><span class="p">[</span><span class="mh">0</span><span class="p">]))</span> <span class="o">:</span> <span class="c1">// BLT &amp; BGE</span>
              <span class="p">((</span><span class="n">op1</span> <span class="o">&lt;</span> <span class="n">op2</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="n">funct3</span><span class="p">[</span><span class="mh">0</span><span class="p">]))))</span> <span class="o">:</span> <span class="c1">// BLTU &amp; BGEU</span>
              <span class="mh">0</span><span class="p">);</span>
</pre></div>
</div>
<p>The shown combinational logics implements the control signal that determines
whether the processor should move its program counter to a different location
other than the next instruction (PC + 4).  <code class="docutils literal notranslate"><span class="pre">ctrl_jump</span></code> signals 1 if the
processor needs to “jump” to other places, which could be caused by branching
(e.g. <code class="docutils literal notranslate"><span class="pre">BNE</span></code>), or function calls (e.g. <code class="docutils literal notranslate"><span class="pre">JAL</span></code>). These control signals will
connect to the logic that fetches the instruction and advances the PC. We’ll
revisit this part later.</p>
<p>Finally, at the end of each cycle, the decoder should already prepare the
decoded information of the instruction, which is stored in SystemVerilog
registers (<code class="docutils literal notranslate"><span class="pre">logic</span></code> is the same as <code class="docutils literal notranslate"><span class="pre">reg</span></code> in this context, essentially flip-flops) so they can be used as the inputs in the next cycle of
the subsequent stage:</p>
<div class="highlight-verilog notranslate"><div class="highlight"><pre><span></span><span class="c1">// ...</span>
<span class="k">output</span> <span class="kt">logic</span> <span class="p">[</span><span class="mh">31</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">op1_reg</span><span class="p">,</span>    <span class="c1">// op1 for ALU</span>
<span class="k">output</span> <span class="kt">logic</span> <span class="p">[</span><span class="mh">31</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">op2_reg</span><span class="p">,</span>    <span class="c1">// op2 for ALU</span>
<span class="k">output</span> <span class="kt">logic</span> <span class="p">[</span><span class="mh">4</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">rd_reg</span><span class="p">,</span>      <span class="c1">// destination general register for writeback</span>
<span class="c1">// ...</span>
<span class="k">output</span> <span class="kt">logic</span> <span class="p">[</span><span class="mh">31</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">tmp_reg</span><span class="p">,</span>    <span class="c1">// keeps some additional value that skips ALU</span>
<span class="k">output</span> <span class="kt">logic</span> <span class="p">[</span><span class="mh">31</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">pc_reg</span><span class="p">,</span>     <span class="c1">// pass on the instruction address</span>
<span class="c1">// ...</span>
<span class="k">output</span> <span class="kt">logic</span> <span class="p">[</span><span class="mh">2</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">ctrl_alu_func_reg</span><span class="p">,</span> <span class="c1">// ALU function selection</span>
<span class="k">output</span> <span class="kt">logic</span> <span class="n">ctrl_alu_sign_ext_reg</span><span class="p">,</span> <span class="c1">//  ALU sign extension flag</span>
<span class="k">output</span> <span class="kt">logic</span> <span class="n">ctrl_nop_reg</span><span class="p">,</span> <span class="c1">// if the current instruction should be treated as a no-op</span>
<span class="k">output</span> <span class="kt">logic</span> <span class="n">ctrl_wb_reg</span><span class="p">,</span> <span class="c1">// if the instruction needs to write back to a register (use rd_reg in WB stage)</span>
<span class="c1">// ...</span>
<span class="k">output</span> <span class="kt">logic</span> <span class="p">[</span><span class="mh">4</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">ctrl_mem_reg</span><span class="p">,</span> <span class="c1">// if the instruction needs to access memory (MEM stage)</span>
<span class="k">output</span> <span class="p">[</span><span class="mh">31</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">ctrl_pc_jump_target</span><span class="p">,</span> <span class="c1">// PC target (only valid if ctrl_jump = 1)</span>
<span class="k">output</span> <span class="n">ctrl_jump</span><span class="p">,</span> <span class="c1">// if there is a (non-trap) control flow transfer</span>
<span class="c1">// ...</span>
<span class="c1">// (see core.sv for the complete implementation)</span>
<span class="c1">// (here we just show one logic path that could prepare the value</span>
<span class="c1">// for `op1_reg`)</span>
                <span class="no">`XXXI</span><span class="o">:</span> <span class="k">begin</span>
                    <span class="n">op1_reg</span> <span class="o">&lt;=</span> <span class="n">op1</span><span class="p">;</span>
                    <span class="n">op2_reg</span> <span class="o">&lt;=</span> <span class="n">xxxi</span><span class="p">;</span>
                    <span class="n">exc_reg</span> <span class="o">&lt;=</span> <span class="n">exc</span><span class="p">;</span>
                    <span class="n">ctrl_alu_func_reg</span> <span class="o">&lt;=</span> <span class="n">funct3</span><span class="p">;</span>
                    <span class="n">ctrl_alu_sign_ext_reg</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">funct3</span> <span class="o">==</span> <span class="no">`FSRX</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">inst</span><span class="p">[</span><span class="mh">30</span><span class="p">];</span>
                    <span class="n">ctrl_wb_reg</span> <span class="o">&lt;=</span> <span class="mh">1</span><span class="p">;</span>
                    <span class="n">ctrl_wb_csr_reg</span> <span class="o">&lt;=</span> <span class="mh">0</span><span class="p">;</span>
                    <span class="n">ctrl_mem_reg</span> <span class="o">&lt;=</span> <span class="mh">0</span><span class="p">;</span>
                <span class="k">end</span>
<span class="c1">// ...</span>
</pre></div>
</div>
</div>
<div class="section" id="executor-all-about-computing">
<h3>Executor: All About “Computing”<a class="headerlink" href="#executor-all-about-computing" title="Permalink to this headline">¶</a></h3>
<p>The executor mostly consists of an ALU (and a multiplier/divider if RISC-V “M”
extension needs to be supported). As a simple implementation, here we just use
a multi-way mux to select the calculation by
<code class="docutils literal notranslate"><span class="pre">ctrl_alu_func</span></code> from last decoder stage, for the given operands:</p>
<div class="highlight-verilog notranslate"><div class="highlight"><pre><span></span><span class="c1">// ...</span>
<span class="kt">wire</span> <span class="p">[</span><span class="mh">31</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">res</span> <span class="o">=</span> <span class="n">ctrl_alu_func</span> <span class="o">==</span> <span class="no">`FADD</span> <span class="o">?</span> <span class="p">(</span><span class="n">ctrl_alu_sign_ext</span> <span class="o">?</span> <span class="n">op1</span> <span class="o">-</span> <span class="n">op2</span> <span class="o">:</span> <span class="n">op1</span> <span class="o">+</span> <span class="n">op2</span><span class="p">)</span> <span class="o">:</span>
           <span class="n">ctrl_alu_func</span> <span class="o">==</span> <span class="no">`FSLT</span> <span class="o">?</span> <span class="p">(</span><span class="n">$signed</span><span class="p">(</span><span class="n">op1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">$signed</span><span class="p">(</span><span class="n">op2</span><span class="p">)</span> <span class="o">?</span> <span class="mh">1</span> <span class="o">:</span> <span class="mh">0</span><span class="p">)</span> <span class="o">:</span>
           <span class="n">ctrl_alu_func</span> <span class="o">==</span> <span class="no">`FSLTU</span> <span class="o">?</span> <span class="p">(</span><span class="n">op1</span> <span class="o">&lt;</span> <span class="n">op2</span> <span class="o">?</span> <span class="mh">1</span> <span class="o">:</span> <span class="mh">0</span><span class="p">)</span> <span class="o">:</span>
           <span class="n">ctrl_alu_func</span> <span class="o">==</span> <span class="no">`FXOR</span> <span class="o">?</span> <span class="p">(</span><span class="n">op1</span> <span class="o">^</span> <span class="n">op2</span><span class="p">)</span> <span class="o">:</span>
           <span class="n">ctrl_alu_func</span> <span class="o">==</span> <span class="no">`FOR</span> <span class="o">?</span> <span class="p">(</span><span class="n">op1</span> <span class="o">|</span> <span class="n">op2</span><span class="p">)</span> <span class="o">:</span>
           <span class="n">ctrl_alu_func</span> <span class="o">==</span> <span class="no">`FAND</span> <span class="o">?</span> <span class="p">(</span><span class="n">op1</span> <span class="o">&amp;</span> <span class="n">op2</span><span class="p">)</span> <span class="o">:</span>
           <span class="n">ctrl_alu_func</span> <span class="o">==</span> <span class="no">`FSLL</span> <span class="o">?</span> <span class="p">(</span><span class="n">op1</span> <span class="o">&lt;&lt;</span> <span class="n">op2</span><span class="p">[</span><span class="mh">4</span><span class="o">:</span><span class="mh">0</span><span class="p">])</span> <span class="o">:</span>
           <span class="n">ctrl_alu_func</span> <span class="o">==</span> <span class="no">`FSRX</span> <span class="o">?</span> <span class="p">(</span><span class="n">ctrl_alu_sign_ext</span> <span class="o">?</span> <span class="n">$signed</span><span class="p">(</span><span class="n">op1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">op2</span><span class="p">[</span><span class="mh">4</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="o">:</span> <span class="n">op1</span> <span class="o">&gt;&gt;</span> <span class="n">op2</span><span class="p">[</span><span class="mh">4</span><span class="o">:</span><span class="mh">0</span><span class="p">])</span> <span class="o">:</span> <span class="p">&#39;</span><span class="n">bx</span><span class="p">;</span>
<span class="c1">// ...</span>
</pre></div>
</div>
<p>For the purpose of this project, we can just use the built-in arithmetic and
logic operations provided by SystemVerilog, which can be reasonably synthesized
for practical use, to support the base instruction set (“I”).  For “M” extension, some
hand-crafted RTL implementation of the multiplier may be desirable, and one can
optimize the different paths of the mux to reduce the latency in the overall
circuitry, which isn’t the focus of this project. Readers who are interested
in this part can try to plug in their own implementations to this module for these
calculations easily.</p>
<p>Finally, as in any other stages, the execution result is stored to a stage
register and some other registers that skip this stage are passed on, by the
end of each cycle:</p>
<div class="highlight-verilog notranslate"><div class="highlight"><pre><span></span><span class="c1">// ...</span>
            <span class="n">res_reg</span> <span class="o">&lt;=</span> <span class="n">res</span><span class="p">;</span>
            <span class="n">rd_reg</span> <span class="o">&lt;=</span> <span class="n">rd</span><span class="p">;</span>
<span class="c1">// ...</span>
            <span class="n">tmp_reg</span> <span class="o">&lt;=</span> <span class="n">tmp</span><span class="p">;</span>
            <span class="n">pc_reg</span> <span class="o">&lt;=</span> <span class="n">pc</span><span class="p">;</span>
            <span class="n">exc_reg</span> <span class="o">&lt;=</span> <span class="n">exc</span><span class="p">;</span>
            <span class="n">ctrl_wb_reg</span> <span class="o">&lt;=</span> <span class="n">ctrl_wb</span><span class="p">;</span>
<span class="c1">// ...</span>
            <span class="n">ctrl_mem_reg</span> <span class="o">&lt;=</span> <span class="n">ctrl_mem</span><span class="p">;</span>
<span class="c1">// ...</span>
</pre></div>
</div>
</div>
<div class="section" id="fetcher-automation-and-loop">
<h3>Fetcher: Automation and Loop<a class="headerlink" href="#fetcher-automation-and-loop" title="Permalink to this headline">¶</a></h3>
<p>So far we know how to decode and execute the instructions, but the processor
still does not automate its work cycles. Like a machine gun, it needs to
automatically feeds in the next instruction to be decoded when last instruction
gets through the decoder, so another round of decoding can happen
when the execution stage continues to work on the decoded instruction. In our code,
a fetching phase, implemented by the <code class="docutils literal notranslate"><span class="pre">fetcher</span></code> module serves as the portal
to the processor pipeline and fetches the correct instruction from the <em>instruction cache</em> (“i-cache”).
We deliberately abstract away the hierarchy of cache and memory in <code class="docutils literal notranslate"><span class="pre">mrisv</span></code>, as a modern
processor usually only directly talks to its L1-cache, whose minimal interface is captured
by our core implementation:</p>
<div class="highlight-verilog notranslate"><div class="highlight"><pre><span></span><span class="c1">// ...</span>
<span class="c1">// i-cache communication</span>
<span class="k">output</span> <span class="p">[</span><span class="mh">31</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">icache_addr</span><span class="p">,</span>
<span class="c1">// request flag, having the level of 1 will trigger a request</span>
<span class="c1">// of 4-byte data at the address given by `icache_addr` when</span>
<span class="c1">// the i-cache is in `idle` state, and it should enter `pending`</span>
<span class="c1">// state in the *next* cycle, which ignores the inputs from the</span>
<span class="c1">// processor and prepare the data in `icache_data`</span>
<span class="k">output</span> <span class="n">icache_req</span><span class="p">,</span>
<span class="k">input</span> <span class="p">[</span><span class="mh">31</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">icache_data</span><span class="p">,</span>
<span class="c1">// ready flag, should be set to 1 when the i-cache is in</span>
<span class="c1">// `pending` state and has stabilized the valid value in</span>
<span class="c1">// `icache_data`. Then it should go back to `idle` in the *next*</span>
<span class="c1">// cycle. Whenever the i-cache is in `idle` state, it sets</span>
<span class="c1">// `icache_rdy` to 0.</span>
<span class="k">input</span> <span class="n">icache_rdy</span><span class="p">,</span>
<span class="c1">// ...</span>
</pre></div>
</div>
<p>Here, <code class="docutils literal notranslate"><span class="pre">icache_addr</span></code> indicates the physical address of the in-memory word
(32-bit integer) the processor wants to fetch next. <code class="docutils literal notranslate"><span class="pre">icache_req</span></code> flag is
maintained at 1 (level-triggered) if a read is requested. When the request flag
is 1 and the i-cache is in <code class="docutils literal notranslate"><span class="pre">idle</span></code>, it enters <code class="docutils literal notranslate"><span class="pre">pending</span></code> state in the <em>next</em>
cycle.  When the word data is stable and ready in <code class="docutils literal notranslate"><span class="pre">icache_data</span></code> wires,
i-cache sets <code class="docutils literal notranslate"><span class="pre">icache_rdy</span></code> to 1. Then it goes back to <code class="docutils literal notranslate"><span class="pre">idle</span></code> state in the
<em>next</em> cycle. Whenever the i-cache is in <code class="docutils literal notranslate"><span class="pre">idle</span></code> state, it maintains <code class="docutils literal notranslate"><span class="pre">icache_rdy</span></code>
at 0.  Thus, it takes at least 1 cycle and may take <em>more</em> cycles to finish
fetching, and our processor accounts for this correctly. The diagram
below shows four continuous reads where each takes 1 cycle, followed by a single read
that takes 3 cycles:</p>
<a class="reference internal image-reference" href="_images/i-cache.svg"><img alt="_images/i-cache.svg" class="align-center" src="_images/i-cache.svg" width="100%" /></a>
<p>To make the entire SoC design runs on
FPGA, readers need to plug in their own cache implementation and memory
controller interface (e.g. some DDR IP core generated by commercial tools such as
Xilinx Vivado) for the i-cache, according to this simple interface. While the
cache interface allows flexibility in interesting use cases, in this repo, we
just emulate i-cache with a few lines of code in <code class="docutils literal notranslate"><span class="pre">sim.cpp</span></code> to demonstrate the
usage and keep our code base minimal and clean (we also use the same implementation
for d-cache that is soon discussed). In our cache/memory simulation, it by default
has a latency of 1 cycle for all access, whereas one can add in extra latency to
simulate more realistic memory access, by calling the
<code class="docutils literal notranslate"><span class="pre">schedule_next_icache_rdy()</span></code> (or <code class="docutils literal notranslate"><span class="pre">schedule_next_dcache_rdy()</span></code> for d-cache)
method of the <code class="docutils literal notranslate"><span class="pre">SimulatedRAM</span></code> object.</p>
<p>To automate the program counter correctly, <code class="docutils literal notranslate"><span class="pre">fetcher</span></code> uses a mux to consider
the following three cases:</p>
<ul class="simple">
<li><p>normal advances of PC: PC + 4 (as each instruction is 4-byte word in RV32I);</p></li>
<li><p>control flow transfers by some previous instruction: <code class="docutils literal notranslate"><span class="pre">ctrl_jump</span></code> and <code class="docutils literal notranslate"><span class="pre">pc_jump_target</span></code> inputs;</p></li>
<li><p>trap (for processor exceptions or interrupts) handling: <code class="docutils literal notranslate"><span class="pre">ctrl_trap</span></code> and <code class="docutils literal notranslate"><span class="pre">pc_exc_target</span></code>.</p></li>
</ul>
<div class="highlight-verilog notranslate"><div class="highlight"><pre><span></span><span class="c1">// ...</span>
<span class="kt">wire</span> <span class="p">[</span><span class="mh">31</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">next_pc</span> <span class="o">=</span> <span class="n">ctrl_jump</span> <span class="o">?</span> <span class="n">pc_jump_target</span> <span class="o">:</span> <span class="p">(</span><span class="n">pc</span> <span class="o">+</span> <span class="mh">4</span><span class="p">);</span>
<span class="c1">// ...</span>
        <span class="n">pc</span> <span class="o">&lt;=</span> <span class="n">ctrl_trap</span> <span class="o">?</span> <span class="n">pc_exc_target</span> <span class="o">:</span> <span class="n">next_pc</span><span class="p">;</span>
        <span class="n">inst_reg</span> <span class="o">&lt;=</span> <span class="n">icache_data</span><span class="p">;</span>
        <span class="n">pc_reg</span> <span class="o">&lt;=</span> <span class="n">pc</span><span class="p">;</span>
<span class="c1">// ...</span>
</pre></div>
</div>
</div>
<div class="section" id="memory-access-writeback">
<h3>Memory Access &amp; Writeback<a class="headerlink" href="#memory-access-writeback" title="Permalink to this headline">¶</a></h3>
<p>Like single-cycle processors, a pipelined design also needs to finalize the
state change at the end of an instruction. There are two kinds of state changes:</p>
<ul class="simple">
<li><p>internal: the change of general/special registers specified by the ISA</p></li>
<li><p>external: the change made to main memory locations, addressed at some byte-level granularity</p></li>
</ul>
<p>For RISC-V, the external state change can only be done via memory store
instructions. Like instruction cache, there is a dedicated in-processor cache,
<em>data cache</em> (“d-cache”) that is used for caching data accessed by the memory loads/stores.</p>
<p>This style of distinguishing the storage of instructions from the data they
work on is usually called <em>Havard architecture</em>, whereas <em>von Neumann
architecture</em> treats instructions and data the same way (“programs are also
data”). For modern computer systems, however, the model is more like a hybrid
version of both: most micro-architectures have separate i-cache and
d-cache for better performance due to the naturally different access patterns of each
kind, while the programs they execute do not have such distinction (both
instructions and data are managed in the same, unified memory space).</p>
<p>Our d-cache interface is very similar to i-cache’s:</p>
<div class="highlight-verilog notranslate"><div class="highlight"><pre><span></span><span class="c1">// ...</span>
<span class="k">output</span> <span class="p">[</span><span class="mh">31</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">dcache_addr</span><span class="p">,</span>
<span class="k">output</span> <span class="p">[</span><span class="mh">31</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">dcache_wdata</span><span class="p">,</span>
<span class="k">output</span> <span class="p">[</span><span class="mh">1</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">dcache_ws</span><span class="p">,</span>
<span class="k">output</span> <span class="n">dcache_req</span><span class="p">,</span>
<span class="k">output</span> <span class="n">dcache_wr</span><span class="p">,</span>
<span class="k">input</span> <span class="p">[</span><span class="mh">31</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">dcache_rdata</span><span class="p">,</span>
<span class="k">input</span> <span class="n">dcache_rdy</span><span class="p">,</span>
<span class="c1">// ...</span>
</pre></div>
</div>
<p>, with the following differences:</p>
<ul class="simple">
<li><p>unlike the read-only i-cache, d-cache can be in either read or write state,
so <code class="docutils literal notranslate"><span class="pre">dcache_wr</span></code> is added as the flag and <code class="docutils literal notranslate"><span class="pre">dcache_wdata</span></code> is added as the
value for writes;</p></li>
<li><p>although all instructions are of the same length, RV32I allows manipulating data
with different widths (bytes, half-words and words), so
<code class="docutils literal notranslate"><span class="pre">dcache_ws</span></code> is required to indicate the width: 0 for bytes, 1 for half-words
and 2 for words.</p></li>
</ul>
<p>The operational logic for d-cache is similar to that for i-cache. It is also a
request-based protocol and the data are placed in the lower bits for sizes
smaller than a word.</p>
<p>The result after memory stage is either the passed-on value from execution stage,
or the value just loaded from the memory:</p>
<div class="highlight-verilog notranslate"><div class="highlight"><pre><span></span><span class="c1">// ...</span>
<span class="kt">wire</span> <span class="p">[</span><span class="mh">31</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">res_mem</span> <span class="o">=</span>
    <span class="n">dcache_ws</span> <span class="o">==</span> <span class="mh">2</span><span class="mb">&#39;b00</span> <span class="o">?</span> <span class="p">{{</span><span class="mh">24</span><span class="p">{</span><span class="n">sgn</span> <span class="o">?</span> <span class="n">rdata</span><span class="p">[</span><span class="mh">7</span><span class="p">]</span> <span class="o">:</span> <span class="mh">1</span><span class="mb">&#39;b0</span><span class="p">}},</span> <span class="n">rdata</span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]}</span> <span class="o">:</span> <span class="c1">// LB/LBU</span>
    <span class="n">dcache_ws</span> <span class="o">==</span> <span class="mh">2</span><span class="mb">&#39;b01</span> <span class="o">?</span> <span class="p">{{</span><span class="mh">16</span><span class="p">{</span><span class="n">sgn</span> <span class="o">?</span> <span class="n">rdata</span><span class="p">[</span><span class="mh">15</span><span class="p">]</span> <span class="o">:</span> <span class="mh">1</span><span class="mb">&#39;b0</span><span class="p">}},</span> <span class="n">rdata</span><span class="p">[</span><span class="mh">15</span><span class="o">:</span><span class="mh">0</span><span class="p">]}</span> <span class="o">:</span> <span class="c1">// LH/LHU</span>
                         <span class="n">rdata</span><span class="p">;</span> <span class="c1">// LW</span>
<span class="kt">wire</span> <span class="p">[</span><span class="mh">31</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">res</span> <span class="o">=</span> <span class="p">(</span><span class="n">ctrl_mem</span><span class="p">[</span><span class="mh">1</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="o">==</span> <span class="mh">2</span><span class="mb">&#39;b10</span><span class="p">)</span> <span class="o">?</span> <span class="n">res_mem</span> <span class="o">:</span> <span class="n">res_alu</span><span class="p">;</span>
<span class="c1">// ...</span>
</pre></div>
</div>
<p>At last, the write-back stage is fairly simple in its logic, as most of it has
already been taken care of in <code class="docutils literal notranslate"><span class="pre">register_file</span></code> module. It just wires the result
to the destination register:</p>
<div class="highlight-verilog notranslate"><div class="highlight"><pre><span></span><span class="c1">// ...</span>
<span class="k">assign</span> <span class="n">reg_waddr</span> <span class="o">=</span> <span class="n">rd</span><span class="p">;</span>
<span class="k">assign</span> <span class="n">reg_wdata</span> <span class="o">=</span> <span class="n">res</span><span class="p">;</span>
<span class="k">assign</span> <span class="n">reg_wen</span> <span class="o">=</span> <span class="n">valid</span> <span class="o">&amp;&amp;</span> <span class="n">ctrl_wb</span><span class="p">;</span>
<span class="c1">// ... (the rest of the code in core.sv is about handling</span>
<span class="c1">// CSR/traps at the end of the pipeline)</span>
</pre></div>
</div>
</div>
<div class="section" id="hazards-stalls-bubbles-and-forwarding">
<h3>Hazards: Stalls, Bubbles and Forwarding<a class="headerlink" href="#hazards-stalls-bubbles-and-forwarding" title="Permalink to this headline">¶</a></h3>
<p>Putting all stages together, we have a pipeline like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">fetcher</span><span class="p">]</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="n">decoder</span><span class="p">]</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="n">executor</span><span class="p">]</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="n">memory</span><span class="p">]</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="n">writeback</span><span class="p">]</span>
         <span class="n">regs</span>         <span class="n">regs</span>          <span class="n">regs</span>        <span class="n">regs</span>
<span class="o">+</span><span class="n">cycles</span><span class="p">:</span>  <span class="mi">1</span>            <span class="mi">2</span>             <span class="mi">3</span>           <span class="mi">4</span>              <span class="mi">5</span>
</pre></div>
</div>
<p>Ideally, the automation seems to work, if we inject <em>independent</em> instructions
from the left, and each stage takes exactly 1 cycle to complete. By these two
assumptions, in each clock cycle, each stage will process exactly one
instruction, sent it over to the next stage and it will take exactly 5
cycles for one instruction to finish the entire pipeline.</p>
<p>Unfortunately, neither assumptions are always true:</p>
<ol class="arabic simple">
<li><p>instructions that are still in the pipeline can be mutually dependent. For example,
a load instruction can write to register <code class="docutils literal notranslate"><span class="pre">x1</span></code> whose value is immediately used in a
subsequent operation like <code class="docutils literal notranslate"><span class="pre">addi</span> <span class="pre">x2,</span> <span class="pre">x1,</span> <span class="pre">1</span></code>;</p></li>
<li><p>each stage may take more than one cycle to complete. For example, both <code class="docutils literal notranslate"><span class="pre">fetcher</span></code> and
<code class="docutils literal notranslate"><span class="pre">memory</span></code> stage can be <em>stalled</em> by cache misses, which waits for the memory to load/store
the data. Memory access are several orders of magnitude slower than cache
(e.g. 100 times) and cache could be hierarchical (an L1 cache miss could
cause an acess to L2 cache, which cannot be done with a single cycle);</p></li>
<li><p>control flow transfer (or traps) can change the normal advancing behavior of
PC and suddenly diverge it to some random location in the program, which
cannot be immediately predicted before fetching the next instruction. So in
our design, when the decoder finds out such change to PC, it is already too
late.</p></li>
</ol>
<p>We call these anomalies that violate the regular progress in the pipeline and
potentially generate incorrect results <em>hazards</em>.
The issue caused by data
dependency is <em>data hazards</em>. Our design is an <em>in-order</em> pipeline where
instructions are pipelined respecting their natural order in
the program (instead of being reordered in those out-of-order implementations
such as scoreboard or Tomasulo), the typical data hazard for us is “read
after write” (RAW, we don’t have WAR or WAW). An example for RAW was given in the first point
of the above list. The second point could also be viewed as a kind of data hazards.
Moreover, our processor is <em>scalar</em> (single stream of instructions and single
stream of data), thus it does not have <em>structural hazards</em> as there are
always sufficient hardware resources for each stage to process data (there can’t be
multiple instructions trying to multiplex the same structure, like ALU, as in
those <em>superscalar</em> processors). We do have <em>control hazards</em> as noted by the
third point.</p>
<p>Therefore, we use three classic techniques to tackle with the hazards:</p>
<ul class="simple">
<li><p>stalls: to generalize the idea and make our implementation clean, we allow
each stage in the pipeline to raise a “stall signal”, which will temporarily
pause the progress <em>before</em> this stage;</p></li>
<li><p>bubbles: to invalidate the instructions that should <em>not</em> have been injected into
the pipeline due to the change of control flow, we mark the instructions in
earlier stages effectively as “no-ops” (similar to the handling of NOP
instruction);</p></li>
<li><p>forwarding: to address RAW issue, we need to forward the results from earlier
instructions that are still in the pipeline to subsequent ones by adding muxes of
“shortcuts”, before the results are actually written back to the register file.</p></li>
</ul>
<p>For each stage, we have a stall signal input and an output such as:</p>
<div class="highlight-verilog notranslate"><div class="highlight"><pre><span></span><span class="c1">// ...</span>
<span class="c1">// whether this stage should be stalled</span>
<span class="c1">// this is determined both by `ctrl_fetcher_stall` (directly)</span>
<span class="c1">// and whether the subsequent stages are stalled (indirectly)</span>
<span class="k">input</span> <span class="n">ctrl_stall</span><span class="p">,</span>
<span class="c1">// whether the next sage should be stalled:</span>
<span class="c1">// - yes: do *not* inject bubble to the input of next stage</span>
<span class="c1">// - no: inject a bubble to the next stage</span>
<span class="k">input</span> <span class="n">ctrl_next_stage_stall</span><span class="p">,</span>
<span class="c1">// ...</span>
<span class="c1">// whether this stage has a hazard that requires</span>
<span class="c1">// stalling itself and its previous stages.</span>
<span class="k">output</span> <span class="n">ctrl_fetcher_stall</span>
<span class="c1">// ...</span>
</pre></div>
</div>
<p>Note that we also need to know whether the next stage is also stalled:
<code class="docutils literal notranslate"><span class="pre">ctrl_next_stage_stall</span></code> wire is the <code class="docutils literal notranslate"><span class="pre">ctrl_stall</span></code> input used by the next
stage, because for any two adjacent stages, if the current stage stalls:</p>
<ul class="simple">
<li><p>the next stage is not stalled, we need to ensure the current stage still
produces something valid, like a bubble at the end of this cycle, otherwise
some stale register values could still persist and there will be a “ghost”
instruction used by the next stage;</p></li>
<li><p>the next stage is also stalled, then no bubble is need.</p></li>
</ul>
<p>It is simply done by the following check in all stages:</p>
<div class="highlight-verilog notranslate"><div class="highlight"><pre><span></span><span class="c1">// ...</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ctrl_next_stage_stall</span><span class="p">)</span> <span class="c1">// insert a bubble</span>
            <span class="n">ctrl_nop_reg</span> <span class="o">&lt;=</span> <span class="mh">1</span><span class="p">;</span>
<span class="c1">// ...</span>
</pre></div>
</div>
<p>Overall, the stall signal <code class="docutils literal notranslate"><span class="pre">ctrl_stall</span></code> for all stages can be calculated in an
organized way:</p>
<div class="highlight-verilog notranslate"><div class="highlight"><pre><span></span><span class="c1">// ...</span>
<span class="kt">wire</span> <span class="n">ctrl_fetcher_stall_in</span> <span class="o">=</span> <span class="n">ctrl_fetcher_stall</span> <span class="o">||</span>
                             <span class="n">ctrl_decoder_stall</span> <span class="o">||</span>
                             <span class="n">ctrl_executor_stall</span> <span class="o">||</span>
                             <span class="n">ctrl_mem_stall</span> <span class="o">||</span>
                             <span class="n">ctrl_writeback_stall</span> <span class="o">||</span>
                             <span class="n">ctrl_wfi_stall</span><span class="p">;</span>

<span class="kt">wire</span> <span class="n">ctrl_decoder_stall_in</span> <span class="o">=</span> <span class="n">ctrl_decoder_stall</span> <span class="o">||</span>
                             <span class="n">ctrl_fetcher_stall</span> <span class="o">||</span> <span class="c1">// because jumps could change PC</span>
                             <span class="n">ctrl_executor_stall</span> <span class="o">||</span>
                             <span class="n">ctrl_mem_stall</span> <span class="o">||</span>
                             <span class="n">ctrl_writeback_stall</span> <span class="o">||</span>
                             <span class="n">ctrl_wfi_stall</span><span class="p">;</span>

<span class="kt">wire</span> <span class="n">ctrl_executor_stall_in</span> <span class="o">=</span> <span class="n">ctrl_executor_stall</span> <span class="o">||</span>
                              <span class="n">ctrl_mem_stall</span> <span class="o">||</span>
                              <span class="n">ctrl_writeback_stall</span> <span class="o">||</span>
                              <span class="n">ctrl_wfi_stall</span><span class="p">;</span>

<span class="kt">wire</span> <span class="n">ctrl_mem_stall_in</span> <span class="o">=</span> <span class="n">ctrl_mem_stall</span> <span class="o">||</span>
                         <span class="n">ctrl_writeback_stall</span> <span class="o">||</span>
                         <span class="n">ctrl_wfi_stall</span><span class="p">;</span>

<span class="kt">wire</span> <span class="n">ctrl_wb_stall_in</span> <span class="o">=</span> <span class="n">ctrl_writeback_stall</span> <span class="o">||</span>
                        <span class="n">ctrl_wfi_stall</span><span class="p">;</span>
<span class="c1">// ...</span>
</pre></div>
</div>
<p>In addition to the bubbles generated by stalls, <code class="docutils literal notranslate"><span class="pre">decoder</span></code> is the one other place that can
generate bubble, when it hits a transfer of control flow. Due to its limited scenario, we can
use an internal register in <code class="docutils literal notranslate"><span class="pre">decoder</span></code> module to indicate whether it should skip the instruction
that immediately comes after the current one:</p>
<div class="highlight-verilog notranslate"><div class="highlight"><pre><span></span><span class="c1">// ...</span>
<span class="kt">logic</span> <span class="n">ctrl_skip_next_reg</span><span class="p">;</span>
<span class="c1">// ...</span>
<span class="kt">wire</span> <span class="n">is_nop</span> <span class="o">=</span> <span class="n">ctrl_nop</span> <span class="o">||</span>
              <span class="n">ctrl_skip_next_reg</span> <span class="o">||</span>
              <span class="n">ctrl_trap</span> <span class="o">||</span>
              <span class="p">(</span><span class="n">opcode</span> <span class="o">==</span> <span class="no">`XXXI</span> <span class="o">&amp;&amp;</span> <span class="n">inst</span><span class="p">[</span><span class="mh">31</span><span class="o">:</span><span class="mh">7</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0</span><span class="p">)</span> <span class="o">||</span>
              <span class="n">opcode</span> <span class="o">==</span> <span class="no">`FEN</span><span class="p">;</span>

<span class="c1">// ...</span>
            <span class="n">ctrl_skip_next_reg</span> <span class="o">&lt;=</span> <span class="n">ctrl_jump</span><span class="p">;</span>
<span class="c1">// ...</span>
            <span class="n">ctrl_skip_next_reg</span> <span class="o">&lt;=</span> <span class="n">ctrl_trap</span><span class="p">;</span>
</pre></div>
</div>
<p>Thus in our pipeline, a transfer of control flow (or an interrupt) will create
exactly one bubble (an exception, however, due to its synchronous nature, will
empty the entire pipeline as discussed later).  It is encouraged for the
readers to read more materials about one important optimization that could be
added to the code – <em>branch predictor</em>. The pipeline will then only suffer
from at most one bubble if the prediction is incorrect.</p>
<p>As for forwarding, we know the entire pipeline so far only has one place to read
general-purpose registers: <code class="docutils literal notranslate"><span class="pre">decoder</span></code> module, whose decoding reads at most two
registers in just one cycle. Then we should look for all places after this
stage where the value of a register could be changed eventually if the
instruction there finally finishes the rest of the pipeline.</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">executor</span></code>: an earlier instruction (1 stage ahead) now in execution could generate a new
value to the destination register. We should forward <code class="docutils literal notranslate"><span class="pre">executor</span></code> result with
bypassing wires (with no delay in cycle).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">memory</span></code>: an earlier instruction (2 stage ahead) now in memory stage could
be a load instruction that writes the value from cache/memory to the
register. Unlike the <code class="docutils literal notranslate"><span class="pre">executor</span></code> case, <code class="docutils literal notranslate"><span class="pre">memory</span></code> may take one or more cycles
to finish the load operation, so we may need to stall the <code class="docutils literal notranslate"><span class="pre">decoder</span></code> to wait for
the register value:</p>
<div class="highlight-verilog notranslate"><div class="highlight"><pre><span></span><span class="c1">// ...</span>
<span class="k">assign</span> <span class="n">ctrl_decoder_stall</span> <span class="o">=</span> <span class="n">ctrl_forward_mload_stall</span> <span class="o">&amp;&amp;</span>
                            <span class="p">(((</span><span class="n">opcode</span> <span class="o">==</span> <span class="no">`XXXI</span> <span class="o">||</span>
                              <span class="n">opcode</span> <span class="o">==</span> <span class="no">`XXX</span> <span class="o">||</span>
                              <span class="n">opcode</span> <span class="o">==</span> <span class="no">`LX</span> <span class="o">||</span>
                              <span class="n">opcode</span> <span class="o">==</span> <span class="no">`SX</span> <span class="o">||</span>
                              <span class="n">opcode</span> <span class="o">==</span> <span class="no">`JALR</span> <span class="o">||</span>
                              <span class="n">opcode</span> <span class="o">==</span> <span class="no">`BXX</span> <span class="o">||</span>
                              <span class="n">opcode</span> <span class="o">==</span> <span class="no">`SYS</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">ctrl_forward_rd_exec</span> <span class="o">==</span> <span class="n">rs1</span><span class="p">)</span> <span class="o">||</span>
                            <span class="p">((</span><span class="n">opcode</span> <span class="o">==</span> <span class="no">`XXX</span> <span class="o">||</span>
                              <span class="n">opcode</span> <span class="o">==</span> <span class="no">`SX</span> <span class="o">||</span>
                              <span class="n">opcode</span> <span class="o">==</span> <span class="no">`JALR</span> <span class="o">||</span>
                              <span class="n">opcode</span> <span class="o">==</span> <span class="no">`BXX</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">ctrl_forward_rd_exec</span> <span class="o">==</span> <span class="n">rs2</span><span class="p">));</span>
<span class="c1">// ...</span>
</pre></div>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">writeback</span></code>: an earlier instruction (3 stage ahead) now in write-back stage could
be writing the same register that is needed by <code class="docutils literal notranslate"><span class="pre">decoder</span></code>. The sequential logic in
<code class="docutils literal notranslate"><span class="pre">register_file</span></code> will only make the written value of register available in the <em>next</em>
cycle, which is too late for the <code class="docutils literal notranslate"><span class="pre">decoder</span></code>. Therefore, we need to allow directly
bypassing the extra cycle if the register is read in the same cycle:</p>
<div class="highlight-verilog notranslate"><div class="highlight"><pre><span></span><span class="c1">// ...</span>
<span class="k">assign</span> <span class="n">rdata1</span> <span class="o">=</span> <span class="n">writing</span> <span class="o">&amp;&amp;</span> <span class="n">waddr</span> <span class="o">==</span> <span class="n">raddr1</span> <span class="o">?</span> <span class="n">wdata</span> <span class="o">:</span> <span class="n">regs</span><span class="p">[</span><span class="n">raddr1</span><span class="p">];</span>
<span class="k">assign</span> <span class="n">rdata2</span> <span class="o">=</span> <span class="n">writing</span> <span class="o">&amp;&amp;</span> <span class="n">waddr</span> <span class="o">==</span> <span class="n">raddr2</span> <span class="o">?</span> <span class="n">wdata</span> <span class="o">:</span> <span class="n">regs</span><span class="p">[</span><span class="n">raddr2</span><span class="p">];</span>
<span class="c1">// ...</span>
</pre></div>
</div>
</li>
</ul>
<p>Overall, each forwarding path is a bundle of three signals:</p>
<ul class="simple">
<li><p>valid bit (1-bit): <code class="docutils literal notranslate"><span class="pre">ctrl_forward_valid_exec</span></code> and <code class="docutils literal notranslate"><span class="pre">ctrl_forward_valid_mem</span></code>,</p></li>
<li><p>forwarded (bypassed) value (32-bit): <code class="docutils literal notranslate"><span class="pre">forward_data_exec</span></code> and <code class="docutils literal notranslate"><span class="pre">forward_data_mem</span></code>,</p></li>
<li><p>destination register (5-bit): <code class="docutils literal notranslate"><span class="pre">ctrl_forward_rd_exec</span></code> and <code class="docutils literal notranslate"><span class="pre">ctrl_forward_rd_mem</span></code>.</p></li>
</ul>
<p>An additional mux is added to each operand (<code class="docutils literal notranslate"><span class="pre">op1</span></code> and <code class="docutils literal notranslate"><span class="pre">op2</span></code>, as shown in the
previous code snippet) to select the forwarded value if it is valid and
matches the register in question.</p>
</div>
<div class="section" id="when-the-execution-gets-interrupted">
<h3>When the Execution Gets Interrupted…<a class="headerlink" href="#when-the-execution-gets-interrupted" title="Permalink to this headline">¶</a></h3>
</div>
</div>
<div class="section" id="emulate-a-realistic-soc-environment">
<h2>Emulate a Realistic SoC environment<a class="headerlink" href="#emulate-a-realistic-soc-environment" title="Permalink to this headline">¶</a></h2>
<div class="section" id="no-longer-a-toy-starting-up-a-compiled-program">
<h3>No Longer a “Toy”: Starting up a compiled program<a class="headerlink" href="#no-longer-a-toy-starting-up-a-compiled-program" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="memory-mapped-registers">
<h3>Memory-Mapped Registers<a class="headerlink" href="#memory-mapped-registers" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="priting-to-the-console">
<h3>Priting to the Console<a class="headerlink" href="#priting-to-the-console" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="timer-event-and-a-basic-library">
<h3>Timer, Event and a Basic Library<a class="headerlink" href="#timer-event-and-a-basic-library" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="a-snake-game">
<h3>A Snake Game<a class="headerlink" href="#a-snake-game" title="Permalink to this headline">¶</a></h3>
</div>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="#">mriscv</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="#">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2021, Ted Yin.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.0.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/index.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>